<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>きっこのゲーム手帖</title>
    <meta name="description" content="きっこのゲームまとめ">
    <meta name="format-detection" content="telephone=no">
    <!-- favicon/webclipicon-->
    <link rel="icon" href="/game/img/favicon.ico">
    <!-- ogp-->
    <meta property="og:site_name" content="きっこのゲーム手帖">
    <meta property="og:url" content="undefined">
    <meta property="og:type" content="article">
    <meta property="og:title">
    <meta property="og:description" content="きっこのゲームまとめ">
    <meta property="og:image" content="https://kikko.pages.dev/game/img/twittercard.jpg">
    <meta property="og:locale" content="ja_JP">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:description" content="きっこのゲームまとめ">
    <meta name="twitter:image:src" content="https://kikko.pages.dev/game/img/twittercard.jpg">
    <!-- css-->
    <link rel="stylesheet" href="/game/css/style.css">
    <link rel="stylesheet" href="https://unpkg.com/ress/dist/ress.min.css">
    <!-- js-->
    <script src="/game/js/script.js" defer></script>
  </head>
  <body>
    <header>
      <h1 class="site-title"><a href="/game/"><img src="/game/img/logo.svg" alt="きっこのゲーム手帖"></a></h1>
      <nav id="navi">
        <ul>
          <li><a href="/game/">ゲームリスト</a></li>
          <li><a href="/game/about.html">配信について</a></li>
          <li><a href="https://www.youtube.com/@coccokikko">Youtube</a></li>
          <li><a href="/">きっこっこ*</a></li>
        </ul>
      </nav>
    </header>
    <main>
      <article class="container" id="page">
        <h2 class="game-title"></h2>
        <section class="page-chest" id="summary">
          <div><img src="class URL {
  constructor(input, base = undefined) {
    // toUSVString is not needed.
    input = `${input}`;
    this[context] = new URLContext();

    if (base !== undefined) {
      base = `${base}`;
    }

    const href = bindingUrl.parse(input, base);

    if (!href) {
      throw new ERR_INVALID_URL(input);
    }

    this.#updateContext(href);
  }

  [inspect.custom](depth, opts) {
    if (this == null ||
        ObjectGetPrototypeOf(this[context]) !== URLContext.prototype) {
      throw new ERR_INVALID_THIS('URL');
    }

    if (typeof depth === 'number' &amp;&amp; depth &lt; 0)
      return this;

    const constructor = getConstructorOf(this) || URL;
    const obj = ObjectCreate({ constructor });

    obj.href = this.href;
    obj.origin = this.origin;
    obj.protocol = this.protocol;
    obj.username = this.username;
    obj.password = this.password;
    obj.host = this.host;
    obj.hostname = this.hostname;
    obj.port = this.port;
    obj.pathname = this.pathname;
    obj.search = this.search;
    obj.searchParams = this.searchParams;
    obj.hash = this.hash;

    if (opts.showHidden) {
      obj[context] = this[context];
    }

    return `${constructor.name} ${inspect(obj, opts)}`;
  }

  #updateContext(href) {
    const ctx = this[context];
    ctx.href = href;

    const {
      0: protocol_end,
      1: username_end,
      2: host_start,
      3: host_end,
      4: port,
      5: pathname_start,
      6: search_start,
      7: hash_start,
      8: scheme_type,
    } = bindingUrl.urlComponents;

    ctx.protocol_end = protocol_end;
    ctx.username_end = username_end;
    ctx.host_start = host_start;
    ctx.host_end = host_end;
    ctx.port = port;
    ctx.pathname_start = pathname_start;
    ctx.search_start = search_start;
    ctx.hash_start = hash_start;
    ctx.scheme_type = scheme_type;

    if (this[searchParams]) {
      if (ctx.hasSearch) {
        this[searchParams][searchParams] = parseParams(this.search);
      } else {
        this[searchParams][searchParams] = [];
      }
    }
  }

  toString() {
    if (!isURL(this))
      throw new ERR_INVALID_THIS('URL');
    return this[context].href;
  }

  get href() {
    if (!isURL(this))
      throw new ERR_INVALID_THIS('URL');
    return this[context].href;
  }

  set href(value) {
    if (!isURL(this))
      throw new ERR_INVALID_THIS('URL');
    value = `${value}`;
    const href = bindingUrl.update(this[context].href, updateActions.kHref, value);
    if (!href) { throw ERR_INVALID_URL(value); }
    this.#updateContext(href);
  }

  // readonly
  get origin() {
    if (!isURL(this))
      throw new ERR_INVALID_THIS('URL');
    const ctx = this[context];
    const protocol = StringPrototypeSlice(ctx.href, 0, ctx.protocol_end);

    // Check if scheme_type is not `NOT_SPECIAL`
    if (ctx.scheme_type !== 1) {
      // Check if scheme_type is `FILE`
      if (ctx.scheme_type === 6) {
        return 'null';
      }
      return `${protocol}//${this.host}`;
    }

    if (protocol === 'blob:') {
      const path = this.pathname;
      if (path.length &gt; 0) {
        try {
          const out = new URL(path);
          if (out[context].scheme_type !== 1) {
            return `${out.protocol}//${out.host}`;
          }
        } catch {
          // Do nothing.
        }
      }
    }

    return 'null';
  }

  get protocol() {
    if (!isURL(this))
      throw new ERR_INVALID_THIS('URL');
    return StringPrototypeSlice(this[context].href, 0, this[context].protocol_end);
  }

  set protocol(value) {
    if (!isURL(this))
      throw new ERR_INVALID_THIS('URL');
    const href = bindingUrl.update(this[context].href, updateActions.kProtocol, `${value}`);
    if (href) {
      this.#updateContext(href);
    }
  }

  get username() {
    if (!isURL(this))
      throw new ERR_INVALID_THIS('URL');
    const ctx = this[context];
    if (ctx.protocol_end + 2 &lt; ctx.username_end) {
      return StringPrototypeSlice(ctx.href, ctx.protocol_end + 2, ctx.username_end);
    }
    return '';
  }

  set username(value) {
    if (!isURL(this))
      throw new ERR_INVALID_THIS('URL');
    const href = bindingUrl.update(this[context].href, updateActions.kUsername, `${value}`);
    if (href) {
      this.#updateContext(href);
    }
  }

  get password() {
    if (!isURL(this))
      throw new ERR_INVALID_THIS('URL');
    const ctx = this[context];
    if (ctx.host_start - ctx.username_end &gt; 0) {
      return StringPrototypeSlice(ctx.href, ctx.username_end + 1, ctx.host_start);
    }
    return '';
  }

  set password(value) {
    if (!isURL(this))
      throw new ERR_INVALID_THIS('URL');
    const href = bindingUrl.update(this[context].href, updateActions.kPassword, `${value}`);
    if (href) {
      this.#updateContext(href);
    }
  }

  get host() {
    if (!isURL(this))
      throw new ERR_INVALID_THIS('URL');
    const ctx = this[context];
    let startsAt = ctx.host_start;
    if (ctx.href[startsAt] === '@') {
      startsAt++;
    }
    // If we have an empty host, then the space between components.host_end and
    // components.pathname_start may be occupied by /.
    if (startsAt === ctx.host_end) {
      return '';
    }
    return StringPrototypeSlice(ctx.href, startsAt, ctx.pathname_start);
  }

  set host(value) {
    if (!isURL(this))
      throw new ERR_INVALID_THIS('URL');
    const href = bindingUrl.update(this[context].href, updateActions.kHost, `${value}`);
    if (href) {
      this.#updateContext(href);
    }
  }

  get hostname() {
    if (!isURL(this))
      throw new ERR_INVALID_THIS('URL');
    const ctx = this[context];
    let startsAt = ctx.host_start;
    // host_start might be &quot;@&quot; if the URL has credentials
    if (ctx.href[startsAt] === '@') {
      startsAt++;
    }
    return StringPrototypeSlice(ctx.href, startsAt, ctx.host_end);
  }

  set hostname(value) {
    if (!isURL(this))
      throw new ERR_INVALID_THIS('URL');
    const href = bindingUrl.update(this[context].href, updateActions.kHostname, `${value}`);
    if (href) {
      this.#updateContext(href);
    }
  }

  get port() {
    if (!isURL(this))
      throw new ERR_INVALID_THIS('URL');
    if (this[context].hasPort) {
      return `${this[context].port}`;
    }
    return '';
  }

  set port(value) {
    if (!isURL(this))
      throw new ERR_INVALID_THIS('URL');
    const href = bindingUrl.update(this[context].href, updateActions.kPort, `${value}`);
    if (href) {
      this.#updateContext(href);
    }
  }

  get pathname() {
    if (!isURL(this))
      throw new ERR_INVALID_THIS('URL');
    const ctx = this[context];
    let endsAt;
    if (ctx.hasSearch) {
      endsAt = ctx.search_start;
    } else if (ctx.hasHash) {
      endsAt = ctx.hash_start;
    }
    return StringPrototypeSlice(ctx.href, ctx.pathname_start, endsAt);
  }

  set pathname(value) {
    if (!isURL(this))
      throw new ERR_INVALID_THIS('URL');
    const href = bindingUrl.update(this[context].href, updateActions.kPathname, `${value}`);
    if (href) {
      this.#updateContext(href);
    }
  }

  get search() {
    if (!isURL(this))
      throw new ERR_INVALID_THIS('URL');
    const ctx = this[context];
    if (!ctx.hasSearch) { return ''; }
    let endsAt = ctx.href.length;
    if (ctx.hasHash) { endsAt = ctx.hash_start; }
    if (endsAt - ctx.search_start &lt;= 1) { return ''; }
    return StringPrototypeSlice(ctx.href, ctx.search_start, endsAt);
  }

  set search(value) {
    if (!isURL(this))
      throw new ERR_INVALID_THIS('URL');
    const href = bindingUrl.update(this[context].href, updateActions.kSearch, toUSVString(value));
    if (href) {
      this.#updateContext(href);
    }
  }

  // readonly
  get searchParams() {
    if (!isURL(this))
      throw new ERR_INVALID_THIS('URL');
    if (this[searchParams] == null) {
      this[searchParams] = new URLSearchParams(this.search);
      this[searchParams][context] = this;
    }
    return this[searchParams];
  }

  get hash() {
    if (!isURL(this))
      throw new ERR_INVALID_THIS('URL');
    const ctx = this[context];
    if (!ctx.hasHash || (ctx.href.length - ctx.hash_start &lt;= 1)) {
      return '';
    }
    return StringPrototypeSlice(ctx.href, ctx.hash_start);
  }

  set hash(value) {
    if (!isURL(this))
      throw new ERR_INVALID_THIS('URL');
    const href = bindingUrl.update(this[context].href, updateActions.kHash, `${value}`);
    if (href) {
      this.#updateContext(href);
    }
  }

  toJSON() {
    if (!isURL(this))
      throw new ERR_INVALID_THIS('URL');
    return this[context].href;
  }

  static canParse(url, base = undefined) {
    url = `${url}`;

    if (base !== undefined) {
      base = `${base}`;
    }

    return bindingUrl.canParse(url, base);
  }

  static createObjectURL(obj) {
    const cryptoRandom = lazyCryptoRandom();
    if (cryptoRandom === undefined)
      throw new ERR_NO_CRYPTO();

    const blob = lazyBlob();
    if (!blob.isBlob(obj))
      throw new ERR_INVALID_ARG_TYPE('obj', 'Blob', obj);

    const id = cryptoRandom.randomUUID();

    storeDataObject(id, obj[blob.kHandle], obj.size, obj.type);

    return `blob:nodedata:${id}`;
  }

  static revokeObjectURL(url) {
    url = `${url}`;
    try {
      // TODO(@anonrig): Remove this try/catch by calling `parse` directly.
      const parsed = new URL(url);
      const split = StringPrototypeSplit(parsed.pathname, ':');
      if (split.length === 2)
        revokeDataObject(split[1]);
    } catch {
      // If there's an error, it's ignored.
    }
  }
}package.jpg" alt width="100%">
            <p class="series"></p>
            <p class="tag"></p>
          </div>
          <div class="text">
            <h3 class="section-title">あらすじ</h3>
            <p>１９４５年。１９３９年から勃発した第二次世界大戦は、意外な形で結末を迎えることになった。</p>
            <p>月と地球の間、２４万ｋｍの距離に突如出現した黒い月、それに続く、幻獣と呼ばれる人類の天敵の出現である。</p>
            <p>人類同士の戦争はそこで終わり、それから５０年。</p>
            <p>中国での焦土作戦失敗とともにユーラシア大陸から追い立てられた人類の存在できる地域は、南北アメリカと南アフリカの一部、そして日本のみとなり、人類と幻獣の戦いは今もって続いている。</p>
            <p>１９９９年。日本もついに学生が戦車の操縦を学ぶ時代になってしまった。 土地の8割と多大な犠牲を支払う歴史的な大敗の末、熊本は日本最後の砦となり、多くの少年達が少年兵として招集される。</p>
          </div>
        </section>
        <section id="video"></section>
        <h3 class="section-title">配信ログ</h3>
        <div class="video-grid"></div>
      </article>
    </main>
    <footer id="footer">
      <p class="inner">&copy; きっこっこ*</p>
    </footer>
    <script src=""></script>
  </body>
</html>